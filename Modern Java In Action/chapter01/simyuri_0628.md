# Chapter01. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

**주요 내용**

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 기능 소개

### 1.1 역사의 흐름은 무엇인가?

자바 역사 통틀어 가장 큰 변화는 자바 8에서 일어났다.

- 스트림 API

  - 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원한느 스트림이라는 새로운 API를 제공한다. 

    -> synchronized를 사용하지 않아도 된다.

- 메서드에 코드를 전달하는 기법(메서드 참조와 람다)

- 인터페이스의 디폴트 메서드

**함수형 프로그래밍**

- 1.1절: 자바가 멀티코어 병렬성(기존의 자바에서 부족했던 특성)을 더 쉽게 이용할 수 있도록 진화하는 과정과 관련 개념을 설명한다.
- 1.2절: 자바 8에서 제공하는 코드를 메서드로 전달하는 기법이 어떻게 강력한 새로운 프로그래밍 도구가 될 수 있는지 설명한다.
- 1.3절: 스트림 API(병렬형 데이터를 표현하고 이들 데이터를 병렬로 처리할 수 있음을 유연하게 보여주는)가 어째서 강력하고 새로운 프로그래밍 도구인지 설명한다.
- 1.4절: 디폴트 메서드라는 새로운 자바 8의 기능을 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는 데 어떻게 활용할 수 있는지 설명한다.
- 1.5절: JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 제시한다.

### 1.2 왜 아직도 자바는 변화하는가?

 새로운 언어가 등장하면서 진화하지 않은 기존 언어는 사장되었다. 우리는 시공을 초월하는 완벽한 언어를 원하지만 현실적으로 그런 언어는 존재하지 않으며 모든 언어가 장단점을 가지고 있다.

특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다. 

#### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

> **자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?**
>
> 객체지향은 1990년대에 두 가지 이유로 각광받았다. 하나는 캡슐화, 다른 하나는 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다는 사실이다.  자바 모델과 자바 코드 애플릿을 안전하게 실행할 수 있었던 초기 브라우저 덕분에 자바가 대학으로 깊숙이 자리 잡을 수 있었고, 졸업생들이 자바를 업계에서 활용하기 시작했다.

 자바는 다양한 임베디드 컴퓨팅 분야(스마트 카드, 토스터, 셋톱박스, 자동차 브레이크 시스템 등)를 성공적으로 장악하고 있다. 하지만 프로그래머는 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다. 즉, 병렬 프로세싱을 활용해야 하는데 지금까지의 자바로는 충분히 대응할 수 없었다. 

 자바 8은 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수할 수 있다는 장점을 제공한다. 

 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념

#### 1.2.2 스트림 처리

**스트림이란** 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 

 자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다. 스트림 패키지에 정의된 Stream<T>는 T형식으로 구성된 일련의 항목을 의미한다. 이제 자바 8에서는 우리가 하려는 작업을 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU코어에 쉽게 할당할 수 있다는 부가적인 이득을 얻을 수 있다. 

#### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

 자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 이론적으로 **동작 파라미터화**라고 부른다.

```java
public int compareUsingCustomerId(String inv1, String inv2) {
  ....
}
```

compareUsingCustomerId를 이용해 sort의 동작을 파라미터화했던 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다. 

#### 1.2.4 병렬성과 공유 가변 데이터

> 병렬성을 공짜로 얻을 수 있다.

 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 보통 다른 코드와 동시에 실행하더라도 **안전하게 실행**할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다. 이러한 함수를 순수 함수, 부작용 없는 함수, 상태 없는 함수라 부르며 추후 자세히 설명한다. 

 물론 기존처럼 synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있을 것이지만, synchronized는 일반적으로 시스템 성능에 악영향을 미친다. 자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다. 

#### 1.2.5 자바가 진화해야 하는 이유

 많은 이가 자바의 변화에 익숙해져있으며 그것이 주는 편리함(컴파일을 할 때 더 많은 에러를 검출할 수 있으며, 리스트의 유형을 알 수 있어 가독성도 좋아졌다.)을 누리고 있다.

 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화향 한다. 자바는 계속 새로운 기능을 추가하면서 인기 언어의 자리를 유지하고 있다. 하지만 새로운 기능이 추가되었다고 하더라도 아무도 이용하지 않는다면 아무 소용이 없다. 

### 1.3 자바 함수

 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다. 

 프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 역사적, 전통적으로 프로그래밍 언어에서는 이 값을 일급 값(또는 시민)이라 부른다.(메서드, 클래스 같은)자바 프로그래밍 언어의 다양한 구조체가 값의 구조를 표현하는 데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다. 메서드, 클래스 등은 이급 자바 시민에 해당한다. 

#### 1.3.1 메서드와 람다를 일급 시민으로

**메서드 참조**라는 새로운 자바 8의 기능을 소개한다. 

```java
File[] hiddenFiles = new File(".").listFiles(Files::isHidden);
```

 isHidden이라는 메서드는 이미 준비되어 있으므로 자바 8의 메서드 참조 ::(이 메서드를 값으로 사용하라는 의미)를 이용해서 listFiles에 직접 전달할 수 있다. 

 자바 8에서는 더 이상 메서드가 이급값이 아닌 일급값이라는 것이다. 

##### 람다 : 익명 함수

 자바 8에서는 메서드 값을 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다. 

#### 1.3.2 코드 넘겨주기 : 예제

**필터** : 특정 항목을 선택해서 반환하는 동작

~~~java
public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple) {
  return apple.getWeight() > 150;
}

//명확히 하기 위해 추가(보통 java.util.function에서 임포트)
public interface Predicate<T> {
  boolean test(T t);
}

// 메서드가 p라는 이름의 프레디케이트 파라미터로 전달됨
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
  List<Apple> result = new ArrayList<>();
  for(Apple apple : inventory) {
    if(p.test(apple)) {
      result.add(apple);
    }
  }
  return result;
}
~~~

다음처럼 메서드를 호출할 수 있다.

~~~java
filterApples(inventory, Apple::isGreenApple);
~~~

또는 다음과 같이 호출해도 된다.

~~~java
filterApples(inventory, Apple::isHeavyApple);
~~~

> **프레디케이트(predicate)란 무엇인가?**
>
> 수학에서는 인수로 값을 받아 true, false 를 반환하는 함수를 프레디케이트라고 부른다. 자바 8에서도 Function<Apple, Boolean>같이 코드를 구현할 수 있지만 Predicate<Apple>을 사용하는 것이 더 표준적인 방식이다. 또한 boolean을 Boolean으로 변환하는 과정이 없으므로 더 효율적이기도 하다.

#### 1.3.3 메서드 전달에서 람다로

자바 8에서는 다음처럼 (익명 함수 또는 람다라는) 새로운 개념을 이용해서 코드를 구현할 수 있다.

~~~java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
// or
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
// or
filterApples(inventory, (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));
~~~

 즉 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다. 하지만 람다가 몇 줄 이상으로 긾어진다면 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 호라용하는 것이 바람직하다. 코드의 명확성이 우선시 되어야 한다.

### 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다. 예를 들어 리스트에서 고가의 트랜젝션(거래)만 필터링한 다음에 통화로 결과를 그룹화해야 한다고 가정하자

~~~java
Map<Currency, List<Transaction>> transactionsByCurrencies = 
  new HashMap<>();
for(Transaction transaction : transactions) {
  if(transaction.getPrice() > 1000) {
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
    if(transasctionsForCurrency == null) {
      transactionsForCurrency = new ArrayList<>();
      transasctionsByCurrencies.put(currency, transactionsForCurrency);
    }
    transactionsForCurrency.add(transaction);
  }
}
~~~

많은 기본 코드를 구현해야 할 뿐만 아니라 중첩된 제어 흐름 문장이 많아서 한 번에 이해하기도 어렵다. 

스트림 API를 이용하면 다음처럼 문제를 해결할 수 있다.

~~~java
import static java.util.stream.Collectors.groupingBy;

Map<Currency, List<Transaction>> transactionsByCurrencies = 
  transactions.stream()
  .filter((Transaction t) -> t.getPrice() > 1000)
  .collect(groupingBy(Transaction::getCurrency));
~~~

 4~7장에 걸쳐 스트림 API를 자세히 설명할 것이므로 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이털르 처리할 수 있다는 사실만 기억하자.

 컬렉션에서는 반복 과정을 직접 처리해야 했다.(for-each 루프 -> **외부 반복**) 반면, 스트림 API에서는 루프를 신경 쓸 필요가 없다. 라이브러리 내부에서 모든 데이터가 처리된다. -> **내부 반복**

 컬렉션을 이용했을 때 다른 문제도 생길 수 있다. 예를 들어, 많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있다.

> **멀티코어 컴퓨터**
>
>  최신 데스크톱과 랩톱 컴퓨터는 모두 멀티코어를 장착했다. 즉, 단일 CPU가 아닌 넷 또는 여덟개 이상의 CPU를 갖는다. 자바 8에서는 이런 컴퓨터를 더 잘 활용할 수 있는 새로운 프로그래밍 스타일을 제공한다. 
>
>  구글의 검색 엔진은 하나의 컴퓨터로는 수행할 수 없는 종류의 코드를 실행하는 좋은 예제다. 

#### 1.4.1 멀티스레딩은 어렵다

 이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다. 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다. 멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다.

 자바 8은 스트림 API로 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 멀티코어 활용 어려움 이라는 두 가지 문제를 모두 해결했다. 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링하거나, 데이터를 추출하거나, 데이터를 그룹화하는 등의 기능이 있다. 

 지금은 새로운 스트림 API도 기존의 컬렉션 API와 아주 비슷한 방식으로 동작한다고(즉, 두 방식 모두 순차적인 데이터 항목 접근 방법을 제공한다고) 간주할 것이다. 다만 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심이다. 컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음에, 리스트로 다시 복원하는 것이다. 스트림과 람다 표현식을 이용하면 병렬성을 공짜로 얻을 수 있으며 리스트에서 무거운 사과를 순차적으로 또는 병렬로 필터링할 수 있다.

> **자바의 병렬성과 공유되지 않은 가변 상태**
>
> 자바 8은 두 가지 요술 방망이를 제공한다.
>
> 우선 라이브러리에서 분할을 처리한다. 즉 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다. 
>
> 또한 filter같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 ㅐ공짜로 병렬성을 누릴 수 있다. 

### 1.5 디폴트 메서드와 자바 모듈

 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 

 우선 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 피키니 모음을 포함하는 모듈을 정의할 수 있다. 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다. 

 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다. (그래서 이를 디폴트 메서드 라고 부른다.)

 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. 

### 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어

1. 메서드와 람다를 일급값으로 사용
2. 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다

### 1.7 마치며

- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 마물면서 사라지게 된다.
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다.
- 함수는 일급값이다.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 
- 기존 자바 기능으로는 대규모 컴포넌트 기반 프로그래밍 그리고 진화하는 시스템의 인터페이스를 적절하게 대응하기 어려웠다.
- 함수형 프로그래미에서 null 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견했다.
